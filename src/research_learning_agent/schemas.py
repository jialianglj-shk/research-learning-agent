from __future__ import annotations

from enum import Enum
from typing import Literal, Any
from pydantic import BaseModel, Field

class UserQuery(BaseModel):
    """User query to the agent."""
    question: str = Field(..., description="The user's natural-language question.")
    session_id: str | None = Field(
        default=None, 
        description="Session ID; used later for personalization."
    )

class SourceItem(BaseModel):
    title: str
    url:str

class LearningMode(str, Enum):
    quick_explain = "quick_explain"
    guided_study = "guided_study"
    deep_research = "deep_research"
    fix_my_problem = "fix_my_problem"

class AnswerSection(BaseModel):
    title: str
    content: str # keep it plain markdown text

class AgentAnswer(BaseModel):
    """Answer generated by the agent."""

    # for backward compatibility
    explanation: str = Field(..., description="Main explanation.")
    bullet_summary: list[str] = Field(
        default_factory=list,
        description="Key takeaways as bullet points."
    )
    model_name: str | None = Field(
        default=None,
        description="LLM model name used.."
    )
    sources: list[SourceItem] = Field(
        default_factory=list, 
        description="Sources used to answer the question."
    )

    # for new learning modes
    mode: LearningMode = LearningMode.quick_explain
    sections: list[AnswerSection] = Field(default_factory=list)

class LLMMessage(BaseModel):
    """Message sent to the LLM."""
    role: str
    content: str

class UserLevel(str, Enum):
    beginner = "beginner"
    intermediate = "intermediate"
    advanced = "advanced"

class LearningIntent(str, Enum):
    casual_curiosity = "casual_curiosity"
    guided_study = "guided_study"
    professional_research = "professional_research"
    urgent_troubleshooting = "urgent_troubleshooting"

class OutputPreference(str, Enum):
    concise = "concise"
    balanced  = "balanced"
    detailed = "detailed"

class UserProfile(BaseModel):
    user_id: str = Field(..., description="Identifier for a local user profile.")
    background: str = Field(..., description="User background summary (free text).")
    level: UserLevel = Field(..., description="Self-reported knowledge level.")
    goals: str = Field(..., description="What the user wants to achieve with this assistant.")
    preferred_output: OutputPreference = Field(default=OutputPreference.balanced)
    preferred_resources: list[str] = Field(default_factory=list, description="e.g. ['videos', 'papers', 'docs']")
    notes: str | None = None

class IntentResult(BaseModel):
    intent: LearningIntent
    confidence: float = Field(..., ge=0.0, le=1.0)
    rationale: str = Field(..., description="Brief reason for classification (1-2 sentences).")
    suggested_output: OutputPreference = OutputPreference.balanced
    should_ask_clarifying_question: bool = False
    clarifying_question: str | None = None
    use_llm: bool = False

class ToolType(str, Enum):
    web_search = "web_search"
    docs_search = "docs_search"
    video_search = "video_search"

class ToolCall(BaseModel):
    tool: ToolType
    query: str
    top_k: int = 5

class ToolError(BaseModel):
    tool: ToolType
    query: str
    error_type: str
    message: str

class ToolResult(BaseModel):
    tool: ToolType
    query: str
    results: list[dict[str, Any]] = Field(default_factory=list)  # each: {title, url, snippet}
    error: ToolError | None = None

class StepType(str, Enum):
    clarify = "clarify"
    outline = "outline"
    explain = "explain"
    study_plan = "study_plan"
    troubleshoot = "troubleshoot"
    research = "research"  # Day 4 will implement tool use
    finalize = "finalize"

class PlanStep(BaseModel):
    step_id: str = Field(..., description="Unique ID within the plan, e.g. s1, s2")
    type: StepType
    description: str
    tool_calls: list[ToolCall] = Field(default_factory=list)
    # design choice: keep steps flexible with inputs/outputs dicts. Will tighten later.
    inputs: dict[str, Any] = Field(default_factory=dict)
    outputs: dict[str, Any] = Field(default_factory=dict)

class Plan(BaseModel):
    goal: str
    intent: str
    steps: list[PlanStep]
    notes: str | None = None

class OrchestratorActionType(str, Enum):
    final = "final"
    need_clarification = "need_clarification"

class OrchestratorAction(BaseModel):
    kind: OrchestratorActionType
    clarifying_question: str | None = None

class OrchestratorResult(BaseModel):
    action: OrchestratorAction
    answer: AgentAnswer | None = None
    intent: IntentResult | None = None
    plan: Plan | None = None
    tool_results: list[ToolResult] = Field(default_factory=list)

class GenerationSpec(BaseModel):
    mode: LearningMode
    required_sections: list[str]
    style_notes: str # short instruction for the generators

class ExplanationStyle(str, Enum):
    examples = "examples"
    formulas = "formulas"
    balanced = "balanced"

class ResourcePreference(str, Enum):
    video = "video"
    text = "text"
    mixed = "mixed"

class Verbosity(str, Enum):
    concise = "concise"
    balanced = "balanced"
    detailed = "detailed"

class UserPreferences(BaseModel):
    explanation_style: ExplanationStyle = ExplanationStyle.balanced
    resource_preference: ResourcePreference = ResourcePreference.mixed
    verbosity: Verbosity = Verbosity.balanced

class MemoryItem(BaseModel):
    ts: str  # ISO datetime string
    query: str
    topic: str
    intent: str
    mode: LearningMode
    summary: str = "" # short summary of what user learned
    followed_up: bool = False # whether user asked a follow-up question

class UserMemory(BaseModel):
    user_id: str = "default"
    topics: list[str] = Field(default_factory=list)  # unique recent topics
    history: list[MemoryItem] = Field(default_factory=list)  # recent N items
    preferences: UserPreferences = Field(default_factory=UserPreferences)
    last_topic: str | None = None
